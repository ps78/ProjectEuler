using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.IO;
using NumberTheory;
using System.Numerics;
using System.Collections.Concurrent;

namespace ProjectEuler
{
    /// <summary>
    /// https://projecteuler.net/problem=101
    /// Solves If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term, 
    /// as there are infinitely many polynomial functions that can model the sequence.
    /// As an example, let us consider the sequence of cube numbers.This is defined by the generating function,
    /// un = n3: 1, 8, 27, 64, 125, 216, ...
    /// Suppose we were only given the first two terms of this sequence.Working on the principle that "simple is best" 
    /// we should assume a linear relationship and predict the next term to be 15 (common difference 7). Even if we 
    /// were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.
    /// We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for the first k terms 
    /// of a sequence.It should be clear that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, 
    /// and potentially the first incorrect term (FIT) will be OP(k, k+1); in which case we shall call it a bad OP(BOP).
    /// As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; 
    /// that is, for n ≥ 2, OP(1, n) = u1.
    /// 
    /// Hence we obtain the following OPs for the cubic sequence:
    /// 
    /// OP(1, n) = 1	1, 1, 1, 1, ...
    /// OP(2, n) = 7n−6	1, 8, 15, ...
    /// OP(3, n) = 6n2−11n+6     	1, 8, 27, 58, ...
    /// OP(4, n) = n3	1, 8, 27, 64, 125, ...
    /// Clearly no BOPs exist for k ≥ 4.
    /// 
    /// By considering the sum of FITs generated by the BOPs(indicated in red above), we obtain 1 + 15 + 58 = 74.
    /// 
    /// Consider the following tenth degree polynomial generating function:
    /// 
    /// un = 1 − n + n2 − n3 + n4 − n5 + n6 − n7 + n8 − n9 + n10
    /// 
    /// Find the sum of FITs for the BOPs.
    /// </summary>
    public class Problem101 : EulerProblemBase
    {
        public Problem101() : base(101, "Optimum polynomial", 0, 37076114526) { }

        private delegate BigInteger OP(int n);
        private delegate BigInteger GeneratingPolyFunc(BigInteger n);

        public override long Solve(long n)
        {
            var poly = new GeneratingPolyFunc(x => 1 - x + x * x - x * x * x + x.BigPower(4) - x.BigPower(5) + x.BigPower(6) - x.BigPower(7) + x.BigPower(8) - x.BigPower(9) + x.BigPower(10));
            //var poly = new GeneratingPolyFunc(n => n * n * n);

            BigInteger fitSum = 0;
            int k = 1;
            while (true)
            {
                var OP = GenerateOP(k, poly);

                // check if k+1-th term equals poly(k+1). If so, we can stop
                if (OP(k + 1) == poly(k + 1))
                    break;
                else
                    fitSum += OP(k + 1);

                k++;
            }
            
            return (long)fitSum;
        }

        /// <summary>
        /// Generates the function OP(k, n) for a given k
        /// </summary>
        private OP GenerateOP(int k, GeneratingPolyFunc poly)
        {
            // OP(1, n) = 1, 1, 1, ...
            if (k == 1) return (x => BigInteger.One);

            // we need the first k terms of the polynomial function, store it in y
            var y = new BigInteger[k];
            for (int i = 0; i < k; i++)
                y[i] = poly(i + 1);

            // now build a linear equation system with k unkonwns and k equations.
            var eqSys = new LinearEquationSystem(k, k);
            for (int j = 0; j < k; j++)
            {
                eqSys[j][0] = - y[j];
                for (int n = 1; n <= k; n++)
                    eqSys[j][n] = ((BigInteger)j + 1).BigPower(n - 1);
            }

            // and solve the system
            var sol = SolveEqSystem(eqSys);

            return new OP((n) =>
            {
                BigInteger result = sol[0];
                for (int i = 1; i < k; i++)
                    result += ((BigInteger)n).BigPower(i) * sol[i];
                return result;
            });
        }

        private BigInteger[] SolveEqSystem(LinearEquationSystem eq)
        {
            var solution = new BigInteger[eq.N];

            // do M solution steps, eliminating one equation in every step
            int firstEq = 0;  // index of first equation of the current, reduced equation system
            int curCoeff = 1; // coefficient index which will be eliminated in the current step
            for (int step = 0; step <= eq.M - 1; step++)
            {
                // keep the current 'firstEq' equation and replace all following equations by 
                // subtracting the 'firstEq' from it.
                for (int eqIdx = firstEq + 1; eqIdx < eq.M; eqIdx++)
                {
                    BigInteger m = eq[eqIdx][curCoeff] / eq[firstEq][curCoeff];
                    var newEq = eq[eqIdx] - (eq[firstEq] * m);
                    eq[eqIdx] = newEq;
                }
                firstEq++;
                curCoeff++;
            }

            // solve the rest by filling the solutions back to the equations
            curCoeff = eq.N;
            for (int eqIdx = eq.M - 1; eqIdx >= 0; eqIdx--)
            {
                BigInteger x = 0;
                for (int j = eq.N; j > curCoeff; j--)
                {
                    x += eq[eqIdx][j] * solution[j - 1];
                }
                solution[curCoeff - 1] = (-eq[eqIdx][0] - x) / eq[eqIdx][curCoeff];
                curCoeff--;
            }

            return solution;
        }
        
    }
}
