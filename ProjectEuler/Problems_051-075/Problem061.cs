using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NumberTheory;
using System.IO;
using System.Numerics;

namespace ProjectEuler
{
    /// <summary>
    /// https://projecteuler.net/problem=61
    /// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate(polygonal) numbers and are generated by the following formulae:
    /// 
    /// Triangle P3, n = n(n + 1) / 2       1, 3, 6, 10, 15, ...
    /// Square P4, n = n2     1, 4, 9, 16, 25, ...
    /// Pentagonal P5, n = n(3n−1) / 2      1, 5, 12, 22, 35, ...
    /// Hexagonal P6, n = n(2n−1)        1, 6, 15, 28, 45, ...
    /// Heptagonal P7, n = n(5n−3) / 2      1, 7, 18, 34, 55, ...
    /// Octagonal P8, n = n(3n−2)        1, 8, 21, 40, 65, ...
    /// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
    /// 
    /// The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
    /// Each polygonal type: triangle(P3,127=8128), square(P4,91=8281), and pentagonal(P5,44=2882), is represented by a different number in the set.
    /// This is the only set of 4-digit numbers with this property.
    /// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
    /// triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
    /// </summary>
    public class Problem061 : EulerProblemBase
    {
        public Problem061() : base(61, "Cyclical figurate numbers", 0, 28684) { }

        public override long Solve(long n)
        {
            var P = BuildSeries();

            bool[] seriesUsed = null;
            PolyNumber[] intermediateResult = null;
            List<PolyNumber[]> results = null;

            FindCyclicSeries(P, ref seriesUsed, ref intermediateResult, 0, ref results);

            // sort the results by sum of the numbers
            results.Sort((s1, s2) => s1.Sum((p) => (int)p.Number).CompareTo(s2.Sum((p) => (int)p.Number)));

            /*
            foreach (var solution in results )
            {
                Console.Write("Solution: <");
                for (int i = 0; i < solution.Length; i++)
                {
                    Console.Write(solution[i].ToString());
                    if (i < solution.Length - 1)
                        Console.Write(", ");
                    else
                        Console.WriteLine(">");
                }    
            }
            */

            if (results.Count == 0)
            {
                Console.WriteLine("No solution found");
                return 0;
            }
            else
                return results.First().Sum((i) => (int)i.Number);
        }

        public class PolyNumber
        {
            public int P { get; private set; }
            public ulong N { get; private set; }
            public ulong Number { get; private set; }
            public int StartDigits { get; private set; }
            public int EndDigits { get; private set; }
            public PolyNumber(int P, ulong n, ulong Number)
            {
                this.P = P;
                this.N = n;
                this.Number = Number;
                string s = Number.ToString();
                this.StartDigits = (int)Number / 100;
                this.EndDigits = (int)Number % 100;
            }
            public override string ToString()
            {
                return "P" + P.ToString() + "," + N.ToString() + " = " + Number.ToString();
            }
        }

        public class PolySeries
        {
            public int P { get; private set; }
            public int Count { get { return Numbers.Count; } }
            public Dictionary<int, HashSet<PolyNumber>> ByStartDigits { get; private set; }
            public Dictionary<int, HashSet<PolyNumber>> ByEndDigits { get; private set; }
            public List<PolyNumber> Numbers { get; private set; }
            public PolySeries(int P)
            {
                this.P = P;
                this.Numbers = new List<PolyNumber>();
                this.ByStartDigits = new Dictionary<int, HashSet<PolyNumber>>();
                this.ByEndDigits = new Dictionary<int, HashSet<PolyNumber>>();      
            }
            public void Add(PolyNumber number)
            {
                Numbers.Add(number);
                
                if (!ByStartDigits.ContainsKey(number.StartDigits))
                    ByStartDigits.Add(number.StartDigits, new HashSet<PolyNumber>());
                ByStartDigits[number.StartDigits].Add(number);

                if (!ByEndDigits.ContainsKey(number.EndDigits))
                    ByEndDigits.Add(number.EndDigits, new HashSet<PolyNumber>());
                ByEndDigits[number.EndDigits].Add(number);
            }
            public override string ToString()
            {
                return "P" + P.ToString() + "-series (" + Count.ToString() + " elements)";
            }
        }

        private void FindCyclicSeries(Dictionary<int, PolySeries> series, ref bool[] seriesUsed, ref PolyNumber[] intermediateResult, int numsFixed, ref List<PolyNumber[]> result)
        {
            if (result == null)
                result = new List<PolyNumber[]>();
            if (seriesUsed == null)
                seriesUsed = new bool[] { false, false, false, false, false, false, false, false, false };
            if (intermediateResult == null)
                intermediateResult = new PolyNumber[] { null, null, null, null, null, null };

            if (numsFixed == 6)
            {
                if (intermediateResult[0].StartDigits == intermediateResult[5].EndDigits)
                {
                    var res = new PolyNumber[6];
                    intermediateResult.CopyTo(res, 0);
                    result.Add(res);
                }
            }
            else if (numsFixed == 0)
            {
                seriesUsed[8] = true;
                foreach (PolyNumber pol in series[8].Numbers)
                {
                    intermediateResult[0] = pol;
                    FindCyclicSeries(series, ref seriesUsed, ref intermediateResult, 1, ref result);
                }
            }
            else
            {
                for (int p = 7; p >= 3; p--)
                    if (!seriesUsed[p])
                    {
                        var lastNum = intermediateResult[numsFixed - 1];
                        seriesUsed[p] = true;
                        if (series[p].ByStartDigits.ContainsKey(lastNum.EndDigits))
                            foreach (var nextNum in series[p].ByStartDigits[lastNum.EndDigits])
                            {
                                intermediateResult[numsFixed] = nextNum;
                                FindCyclicSeries(series, ref seriesUsed, ref intermediateResult, numsFixed + 1, ref result);
                                intermediateResult[numsFixed] = null;
                            }
                        seriesUsed[p] = false;
                    }
            }
        }

        private Dictionary<int, PolySeries> BuildSeries()
        {
            var P = new Dictionary<int, PolySeries>();

            for (int p = 3; p <= 8; p++)
            {
                var series = new PolySeries(p);
                ulong n = 1;
                while (true)
                {
                    ulong Pnum = PolygonalNumber.P(p, n++);
                    if (Pnum > 9999)
                        break;
                    if ((Pnum >= 1000))
                        series.Add(new PolyNumber(p, n, Pnum));
                }
                P.Add(p, series);
            }
            return P;
       }
    }
}
