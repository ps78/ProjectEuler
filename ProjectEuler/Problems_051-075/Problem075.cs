using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NumberTheory;
using System.Numerics;
using System.IO;

namespace ProjectEuler
{
    /// <summary>
    /// https://projecteuler.net/problem=75
    /// It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right angle 
    /// triangle in exactly one way, but there are many more examples.
    /// 12 cm: (3,4,5)
    /// 24 cm: (6,8,10)
    /// 30 cm: (5,12,13)
    /// 36 cm: (9,12,15)
    /// 40 cm: (8,15,17)
    /// 48 cm: (12,16,20)
    /// 
    /// In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right angle triangle, and other 
    /// lengths allow more than one solution to be found; for example, using 120 cm it is possible to form exactly three
    /// different integer sided right angle triangles.
    /// 
    /// 120 cm: (30,40,50), (20,48,52), (24,45,51)
    /// 
    /// Given that L is the length of the wire, for how many values of L ≤ 1,500,000 can exactly one integer 
    /// sided right angle triangle be formed?
    /// </summary>
    public class Problem075 : EulerProblemBase
    {
        public Problem075() : base(75, "Singular integer right triangles", 1_500_000, 161667) { }

        public override bool Test() => Solve(50) == 6;

        public override long Solve(long n)
        {
            // for each Pythagorean triple (a,b,c), (k*a, k*b, k*c), k>1 is also a Pythagorean triple
            // hence L = a+b+c > 750'000 (1'500'000/2)

            // for m > n > 0 and (m,n) coprime, i.e. GCD(m,n) = 1, 
            // primitive triples (a,b,c) are generated by:
            // a = m^2-n^2, b = 2mn, c = m^2+n^2
            // L = a+b+c = 2m^2 + 2mn            
            long maxL = n;
            var counts = new Dictionary<long, bool>(); // key = L, value = unique triple?
            for (long i = 1; i <= (maxL - 8)/4; i++)
            {
                // since L = 2m^2 + 2mn, the equation can be solved for m, given n
                // result is m = (-n + sqrt(n^2+2L)) / 2                
                long minM = i + 1;
                long maxM = (long)Math.Floor((-i + Math.Sqrt(i * i + 2 * maxL)) / 2);

                for (long m = minM; m <= maxM; m++)
                    if (m % 2 == 0 || i % 2 == 0) // m and n must not both be odd
                    if (GCD.Compute(m, i) == 1)
                    {
                        int k = 1;
                        while(true)
                        {
                            long a = k * (m * m - i * i);
                            long b = k * 2 * m * i;
                            long c = k * (m * m + i * i);
                            long L = a + b + c;

                            if (L > maxL)
                                break;
                            else
                            {
                                //Console.WriteLine("(n,m) = ({4},{5}) | (a,b,c) = ({0},{1},{2}) | / L = {3}", triple.Item1, triple.Item2, c, L, n, m);
                                if (counts.ContainsKey(L))
                                    counts[L] = false;
                                else
                                    counts.Add(L, true);
                            }
                            k++;
                        }
                    }
            }

            //counts.Where(kv => kv.Value).Select(kv => kv.Key).OrderBy(_ => _).ToList().ForEach(v => Console.WriteLine("L = {0}", v));

            return counts.Count(kv => kv.Value);
        }
    }
}
