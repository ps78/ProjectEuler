using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NumberTheory;

namespace ProjectEuler
{
    /// <summary>
    /// https://projecteuler.net/problem=12
    /// 
    /// The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
    /// 
    /// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    /// 
    /// Let us list the factors of the first seven triangle numbers:
    /// 
    ///  1: 1
    ///  3: 1,3
    ///  6: 1,2,3,6
    /// 10: 1,2,5,10
    /// 15: 1,3,5,15
    /// 21: 1,3,7,21
    /// 28: 1,2,4,7,14,28
    /// We can see that 28 is the first triangle number to have over five divisors.
    /// 
    /// What is the value of the first triangle number to have over five hundred divisors?
    /// </summary>
    public class Problem012 : EulerProblemBase
    {
        public Problem012() : base(12, "Highly divisible triangular number", 500, 76576500) { }

        public override bool Test() => Solve(5) == 28;

        private SieveOfEratosthenes sieve;
        private ulong[] primes;
        private Dictionary<ulong, ulong> divCounts;

        public override long Solve(long n)
        {
            sieve = new SieveOfEratosthenes(20000); // must be set >= sqrt(largest triangle number)
            primes = sieve.GetPrimes().ToArray();
            divCounts = new Dictionary<ulong, ulong>();

            ulong divCount = 0;
            ulong triangleNumber = 1;
            ulong index = 1;
            while (divCount <= (ulong)n)
            {
                index++;
                triangleNumber += index;
                divCount = GetDivisorCount(triangleNumber, index);
                divCounts.Add(triangleNumber, divCount);
            }
            
            return (long)triangleNumber;
        }

        /// <summary>
        /// Calculates the number of divisors D(t) for t = n*(n+1)/2
        /// </summary>
        /// <param name="n"></param>
        /// <returns></returns>
        public ulong GetDivisorCount(ulong t, ulong n = 0)
        {            
            // lookup if possible
            if (divCounts.ContainsKey(t))
                return divCounts[t];

            // do max. one step of recursion, to gain performance
            if (n != 0)
            {
                // if n is even, D(t) = D(n/2) * D(n+1)
                if (n % 2 == 0)
                {
                    ulong n_half = divCounts.ContainsKey(n / 2) ? divCounts[n / 2] : GetDivisorCount(n / 2);
                    ulong n_p1 = divCounts.ContainsKey(n + 1) ? divCounts[n + 1] : GetDivisorCount(n + 1);
                    return n_half * n_p1;
                }
                // if n is odd D(t) = D(n) * D((n+1)/2)
                else
                {
                    ulong np2 = (n + 1) / 2;
                    ulong n0 = divCounts.ContainsKey(n) ? divCounts[n] : GetDivisorCount(n);
                    ulong n_p1d2 = divCounts.ContainsKey(np2) ? divCounts[np2] : GetDivisorCount(np2);
                    return n0 * n_p1d2;
                }
            }

            var factors = sieve.GetPrimeFactors(t, primes);
            ulong result = 1;
            foreach (var factor in factors)
                result *= (factor.Item2 + 1);

            return result;            
        }
    }
}
