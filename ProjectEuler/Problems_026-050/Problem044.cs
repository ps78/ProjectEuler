using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NumberTheory;

namespace ProjectEuler
{
    /// <summary>
    /// https://projecteuler.net/problem=44
    /// Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
    /// 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
    /// It can be seen that P4 + P7 = 22 + 70 = 92 = P8.However, their difference, 70 − 22 = 48, is not pentagonal.
    /// Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = | Pk − Pj| is minimised; what is the value of D?
    /// </summary>
    public class Problem044 : EulerProblemBase
    {
        public Problem044() : base(44, "Pentagon numbers", 0, 5482660) { }

        public override long Solve(long n)
        {
            // this is solution is cheating a bit as we would need to test all P(i) for i up to ~2000000, 
            // to ensure that no other pair is found with a smaller difference than the solution, 
            // which takes too long
            int m = 2500;
            var pentNumbers = new List<ulong>();
            for (int i = 2; i <= m + 1; i++)
                pentNumbers.Add((ulong)(i * (3*i - 1) / 2));

            var solution = new Tuple<ulong, ulong>(0, ulong.MaxValue);
            for (int i = 1; i < m; i++)
                for (int j = i + 1; j < m; j++)
                {
                    ulong Pi = pentNumbers[i];
                    ulong Pj = pentNumbers[j];

                    if (Pj - Pi > solution.Item2 - solution.Item1)
                        break;

                    if (IsPentagonal(Pi + Pj) && IsPentagonal(Pj - Pi))
                        solution = new Tuple<ulong, ulong>(Pi, Pj);
                }

            return (long)(solution.Item2 - solution.Item1);            
        }

        private bool IsPentagonal(ulong n)
        {
            if (IsPerfectSquare(1 + 24 * n))
            {
                return Math.Abs(Math.IEEERemainder(  ((1 + Math.Sqrt(1 + 24 * n)) / 6.0), 1.0)) < 1e-8;
            }
            return false;
        }

        private bool IsPerfectSquare(ulong n)
        {
            ulong h = n & 0xF;  // h is the last hex "digit"
            if (h > 9)
                return false;

            // Use lazy evaluation to jump out of the if statement as soon as possible
            if (h != 2 && h != 3 && h != 5 && h != 6 && h != 7 && h != 8)
            {
                ulong t = (ulong)Math.Floor(Math.Sqrt((double)n) + 0.5);
                return t * t == n;
            }
            return false;
        }

        
        /* this would be the right solution:
        from itertools import count


    def int_sqrt(n):
    # An integer-arithmetic variant of the Babylonian method for
    # calculating square roots.  Given a non-negative integer n, we find
    # the greatest non-negative integer k such that k*k <= n.
    #
    # Suppose k > 0 is an integer such that k*k > n.  Then
    # k + n//k < 2*k, and because 2*k is even it follows that
    # (k + n//k)//2 < k.  Furthermore,
    #
    #     (k + n/k)**2
    #         == k**2 + 2*n + (n/k)**2
    #         == k**2 - 2*n + (n/k)**2 + 4*n
    #         == (k - n/k)**2 + 4*n
    #         > 4*n
    #
    # so
    #
    #     (k + n/k)/2 > sqrt(4*n)/2 == sqrt(n)
    #         => (k + n//k)//2 >= int_sqrt(n).
    #
    # Thus, by starting with k such that k*k >= n and iteratively
    # replacing k with (k + n//k)//2 while k*k > n we will eventually
    # reach a point where k*k <= n.  At this point, it must be that
    # k == int_sqrt(n).
    #
    # k = n is a natural starting point.  Instead, we will take
    #
    #     k = 1 << -(-n.bit_length()//2)
    #
    # which is a much better initial approximation and so will result in
    # fewer iterations.  Note the use of the idiom -(-x//y) for "divide
    # x by y and round up".  Note also that
    #
    #     k*k
    #         == (1 << -(-n.bit_length()//2))**2
    #         == 1 << (-(-n.bit_length()//2))*2
    #         >= 1 << n.bit_length()
    #         > n,
    #
    # satisfying the algorithmic requirement that k*k >= n initially.
    #
    k = 1 << -(-n.bit_length()//2)
    while k*k > n:
    k = (k + n//k)//2
    return k


    def pentagonal_number(n):
    return n*(3*n - 1)//2


    def is_pentagonal(n):
    # If n is pentagonal then there exists k such that
    #
    #     n == pentagonal_number(k)
    #         =>  n == k*(3*k - 1)/2
    #         =>  2*n == 3*k**2 - k
    #         =>  24*n == (6*k)**2 - 12*k
    #         =>  24*n + 1 == (6*k - 1)**2
    #         =>  int_sqrt(24*n + 1) == 6*k - 1
    #         =>  (int_sqrt(24*n + 1) + 1)//6 == k
    #
    # Thus, n is pentagonal if and only if it is the kth pentagonal
    # number where
    #
    #     k = (int_sqrt(24*n + 1) + 1)//6.
    #
    k = (int_sqrt(24*n + 1) + 1)//6
    return pentagonal_number(k) == n


    def answer():
    # If p[j], p[k] are two pentagonal numbers with j < k then
    #
    #    p[k] - p[j]
    #        == k*(3*k - 1)/2 - j*(3*j - 1)/2
    #        == (3*k*k - k - 3*j*j + j)/2
    #        == (3*k*k - 6*k*j + 3*j*j - k + j + 6*k*j - 6*j*j)/2
    #        == (3*(k-j)**2 - (k-j) + 6*j*(k-j))/2
    #        == p[k-j] + 3*j*(k-j).
    #
    # We are interested only in pairs (j, k) where this differences is
    # itself a pentagonal number, p[t] say.  Setting s = k - j we have
    #
    #     p[t] == p[s] + 3*j*s.
    #
    # Thus, it suffices to consider only pairs (s, t) with s < t for
    # which p[t] - p[s] is a multiple of 3*s.  Any such pair
    # automatically yields j and k such that p[k] - p[j] == p[t] leaving
    # us needing only to check that p[j] + p[k] is pentagonal.
    #
    # Because we want the minimum p[t] with the above properties, we
    # consider each s < t before moving on to t + 1.  Given the relative
    # expense of calculating (p[t] - p[s]) % (3*s) we first screen
    # candidate values of s in view of the following.
    #
    # (1) For all non-negative integers n,
    #
    #     (p[n] - n)%3
    #         == (n*(3*n - 1)/2 - n)%3
    #         == (n*(3*n - 3)/2)%3
    #         == 0
    #
    # Thus, if (p[t] - p[s]) % (3*s) == 0 then we must have that
    # (t - s)%3 == 0.
    #
    # (2) If (p[t] - p[s]) % (3*s) == 0 then
    #
    #     (p[t] - p[s]) % s == 0
    #         => (2*p[t] - 2*p[s]) % s == 0
    #         => (2*p[t] - s*(3*s - 1)) % s == 0
    #         => 2*p[t] % s == 0
    #
    p = {}
    for t in count():
    p[t] = pentagonal_number(t)
    double_p_t = 2 * p[t]
    for s in range(t - 3, 0, -3):
        if not double_p_t % s and not (p[t] - p[s]) % (3*s):
            j = (p[t] - p[s]) // (3*s)
            if is_pentagonal(p[t] + 2*pentagonal_number(j)):
                return p[t]


    print(answer())

        */

    }
    
}
